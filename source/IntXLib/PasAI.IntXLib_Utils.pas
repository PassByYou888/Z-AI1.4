// https://github.com/Xor-el/IntXLib4Pascal
unit PasAI.IntXLib_Utils;

{$I PasAI.IntXLib.inc}

interface

uses
  PasAI.IntXLib_Types;

type

  /// <summary>
  /// Custom class that contains various helper functions.
  /// </summary>
  TUtils = class sealed(TObject)
  public
    /// <summary>
    /// Calculates Arithmetic shift right.
    /// </summary>
    /// <param name="AValue">Integer value to compute 'Asr' on.</param>
    /// <param name="AShiftBits">Byte, number of bits to shift value to.</param>
    /// <returns>Shifted value.</returns>
    /// <remarks>
    /// Emulated Implementation was gotten from FreePascal sources
    /// </remarks>
    class function Asr32(AValue: Integer; AShiftBits: Byte): Integer; static; inline;

    /// <summary>
    /// Calculates Arithmetic shift right.
    /// </summary>
    /// <param name="AValue">Int64 value to compute 'Asr' on.</param>
    /// <param name="AShiftBits">Byte, number of bits to shift value to.</param>
    /// <returns>Shifted value.</returns>
    /// <remarks>
    /// Emulated Implementation was gotten from FreePascal sources
    /// </remarks>
    class function Asr64(AValue: Int64; AShiftBits: Byte): Int64; static; inline;

    // Lifted from DaThoX Free Pascal generics library with little modifications.
    class procedure QuickSort(var AValues: TIntXLibCharArray; ALeft, ARight: Integer); static;
  end;

implementation

class function TUtils.Asr32(AValue: Integer; AShiftBits: Byte): Integer;
begin
{$IFDEF FPC}
  Result := SarLongInt(AValue, AShiftBits);
{$ELSE}
  Result := Int32(UInt32(UInt32(UInt32(AValue) shr (AShiftBits and 31)) or
    (UInt32(Int32(UInt32(0 - UInt32(UInt32(AValue) shr 31)) and
    UInt32(Int32(0 - (Ord((AShiftBits and 31) <> 0) { and 1 } )))))
    shl (32 - (AShiftBits and 31)))));
{$ENDIF FPC}
end;

class function TUtils.Asr64(AValue: Int64; AShiftBits: Byte): Int64;
begin
{$IFDEF FPC}
  Result := SarInt64(AValue, AShiftBits);
{$ELSE}
  Result := Int64(UInt64(UInt64(UInt64(AValue) shr (AShiftBits and 63)) or
    (UInt64(Int64(UInt64(0 - UInt64(UInt64(AValue) shr 63)) and
    UInt64(Int64(0 - (Ord((AShiftBits and 63) <> 0) { and 1 } )))))
    shl (64 - (AShiftBits and 63)))));
{$ENDIF FPC}
end;

class procedure TUtils.QuickSort(var AValues: TIntXLibCharArray; ALeft, ARight: Integer);
var
  I, J: Integer;
  P, Q: Char;
begin
  if ((ARight - ALeft) <= 0) or (Length(AValues) = 0) then
      Exit;
  repeat
    I := ALeft;
    J := ARight;
    P := AValues[ALeft + (ARight - ALeft) shr 1];
    repeat
      while AValues[I] < P do
          Inc(I);
      while AValues[J] > P do
          Dec(J);
      if I <= J then
        begin
          if I <> J then
            begin
              Q := AValues[I];
              AValues[I] := AValues[J];
              AValues[J] := Q;
            end;
          Inc(I);
          Dec(J);
        end;
    until I > J;
    // sort the smaller range recursively
    // sort the bigger range via the loop
    // Reasons: memory usage is O(log(n)) instead of O(n) and loop is faster than recursion
    if J - ALeft < ARight - I then
      begin
        if ALeft < J then
            QuickSort(AValues, ALeft, J);
        ALeft := I;
      end
    else
      begin
        if I < ARight then
            QuickSort(AValues, I, ARight);
        ARight := J;
      end;
  until ALeft >= ARight;
end;

end.
